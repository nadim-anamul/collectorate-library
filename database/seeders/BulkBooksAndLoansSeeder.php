<?php

namespace Database\Seeders;

use App\Models\Author;
use App\Models\Language;
use App\Models\Publisher;
use App\Models\Models\Book;
use App\Models\Models\Category;
use App\Models\Models\Loan;
use App\Models\User;
use Carbon\Carbon;
use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;

class BulkBooksAndLoansSeeder extends Seeder
{
    public function run(): void
    {
        // Ensure base refs exist
        $this->seedBaseReferences();

        // Create/ensure a pool of approved users
        $users = $this->ensureApprovedUsers(200);

        // Create ~1000 books with cover images
        $books = $this->createBooksWithCovers(1000);

        // Generate loan history
        $this->generateLoanHistory($books, $users);
    }

    protected function seedBaseReferences(): void
    {
        // Minimal sets of categories, languages, publishers, authors
        $categories = [
            'Fiction','Non-Fiction','Poetry','Mystery','Biography','History','Science','Philosophy','Children','Technology'
        ];
        foreach ($categories as $name) {
            Category::firstOrCreate(
                ['slug' => Str::slug($name)],
                ['name_en' => $name, 'name_bn' => $name]
            );
        }

        $langs = [
            ['code' => 'en', 'name' => 'English'],
            ['code' => 'bn', 'name' => 'Bengali'],
            ['code' => 'hi', 'name' => 'Hindi'],
        ];
        foreach ($langs as $l) {
            Language::firstOrCreate(['code' => $l['code']], ['name' => $l['name']]);
        }

        $publishers = ['Penguin Random House','HarperCollins','Simon & Schuster','Ananda Publishers','Somoy Prakashan'];
        foreach ($publishers as $p) {
            Publisher::firstOrCreate(['name_en' => $p], ['name_bn' => $p]);
        }

        $authorNames = [
            'Rabindranath Tagore','Kazi Nazrul Islam','Humayun Ahmed','Sarat Chandra Chattopadhyay','Bibhutibhushan Bandyopadhyay',
            'Jane Austen','George Orwell','F. Scott Fitzgerald','Leo Tolstoy','Charles Dickens','Mark Twain','Virginia Woolf'
        ];
        foreach ($authorNames as $name) {
            Author::firstOrCreate(['name_en' => $name], ['name_bn' => $name]);
        }
    }

    protected function ensureApprovedUsers(int $count): \Illuminate\Support\Collection
    {
        $existing = User::where('status','approved')->get();
        $needed = max(0, $count - $existing->count());
        for ($i = 0; $i < $needed; $i++) {
            $name = 'Test User '.Str::padLeft((string)($existing->count() + $i + 1), 4, '0');
            $email = 'user'.Str::padLeft((string)($existing->count() + $i + 1), 4, '0').'@example.com';
            $user = User::firstOrCreate(
                ['email' => $email],
                [
                    'name' => $name,
                    'password' => bcrypt('password'),
                    'status' => 'approved',
                ]
            );
            if (method_exists($user, 'assignRole')) {
                try { $user->assignRole('Member'); } catch (\Throwable $e) {}
            }
        }
        return User::where('status','approved')->get();
    }

    protected function createBooksWithCovers(int $count): \Illuminate\Support\Collection
    {
        $categories = Category::all();
        $publishers = Publisher::all();
        $languages = Language::all();
        $authors = Author::all();

        $books = collect();
        for ($i = 0; $i < $count; $i++) {
            $title = $this->randomTitle();
            $category = $categories->random();
            $publisher = $publishers->random();
            $language = $languages->random();
            $primaryAuthor = $authors->random();

            $totalCopies = rand(1, 8);
            $isbn = $this->fakeIsbn13();

            $coverPath = $this->downloadRandomCover();

            $book = Book::create([
                'title_en' => $title,
                'title_bn' => null, // Not all books have Bengali titles
                'category_id' => $category->id,
                'primary_author_id' => $primaryAuthor->id,
                'publisher_id' => $publisher->id,
                'language_id' => $language->id,
                'isbn' => $isbn,
                'publication_year' => rand(1950, (int)date('Y')),
                'pages' => rand(120, 900),
                'description_en' => 'Autogenerated demo book for system testing.',
                'description_bn' => null,
                'available_copies' => $totalCopies,
                'total_copies' => $totalCopies,
                'cover_path' => $coverPath,
            ]);

            $book->authors()->syncWithoutDetaching([$primaryAuthor->id]);
            $books->push($book);
        }

        return $books;
    }

    protected function generateLoanHistory(\Illuminate\Support\Collection $books, \Illuminate\Support\Collection $users): void
    {
        // Create a mix of returned, issued, pending, return_requested, declined
        $now = Carbon::now();

        foreach ($books as $book) {
            $historyCount = rand(0, 5); // past loans
            for ($h = 0; $h < $historyCount; $h++) {
                $user = $users->random();
                $issuedAt = $now->copy()->subDays(rand(30, 365));
                $dueAt = $issuedAt->copy()->addDays(rand(7, 30));
                $returnedAt = rand(0,1) ? $dueAt->copy()->subDays(rand(0, 5)) : $dueAt->copy()->addDays(rand(0, 10));

                Loan::create([
                    'book_id' => $book->id,
                    'user_id' => $user->id,
                    'issued_by_user_id' => null,
                    'requested_at' => $issuedAt->copy()->subDays(1)->toDateString(),
                    'requested_due_at' => null,
                    'issued_at' => $issuedAt->toDateString(),
                    'due_at' => $dueAt->toDateString(),
                    'returned_at' => $returnedAt->toDateString(),
                    'status' => 'returned',
                ]);
            }

            // Current state: zero or more active loans/requests
            $activeCount = rand(0, min(2, $book->total_copies));
            $currentIssued = 0;
            for ($a = 0; $a < $activeCount; $a++) {
                $user = $users->random();
                $r = rand(1, 100);
                if ($r <= 60) {
                    // issued (some overdue)
                    $issuedAt = $now->copy()->subDays(rand(0, 20));
                    $dueAt = $issuedAt->copy()->addDays(rand(7, 21));
                    $overdueAt = null;
                    if ($dueAt->lt($now)) { $overdueAt = $now->copy()->toDateString(); }
                    Loan::create([
                        'book_id' => $book->id,
                        'user_id' => $user->id,
                        'issued_by_user_id' => null,
                        'requested_at' => $issuedAt->copy()->subDays(1)->toDateString(),
                        'requested_due_at' => null,
                        'issued_at' => $issuedAt->toDateString(),
                        'due_at' => $dueAt->toDateString(),
                        'returned_at' => null,
                        'status' => 'issued',
                        'overdue_at' => $overdueAt,
                    ]);
                    $currentIssued++;
                } elseif ($r <= 85) {
                    // pending
                    Loan::create([
                        'book_id' => $book->id,
                        'user_id' => $user->id,
                        'issued_by_user_id' => null,
                        'requested_at' => $now->copy()->subDays(rand(0, 5))->toDateString(),
                        'requested_due_at' => null,
                        'issued_at' => null,
                        'due_at' => null,
                        'returned_at' => null,
                        'status' => 'pending',
                    ]);
                } else {
                    // return_requested (on an issued)
                    $issuedAt = $now->copy()->subDays(rand(1, 14));
                    $dueAt = $issuedAt->copy()->addDays(rand(7, 21));
                    Loan::create([
                        'book_id' => $book->id,
                        'user_id' => $user->id,
                        'issued_by_user_id' => null,
                        'requested_at' => $issuedAt->copy()->subDays(1)->toDateString(),
                        'requested_due_at' => null,
                        'issued_at' => $issuedAt->toDateString(),
                        'due_at' => $dueAt->toDateString(),
                        'returned_at' => null,
                        'status' => 'return_requested',
                    ]);
                    $currentIssued++;
                }
            }

            // Update availability based on issued count
            $available = max(0, $book->total_copies - $currentIssued);
            $book->update(['available_copies' => $available]);
        }
    }

    protected function randomTitle(): string
    {
        $adjectives = ['Silent','Hidden','Lost','Bright','Invisible','Crimson','Golden','Midnight','Distant','Broken','Sacred'];
        $nouns = ['Forest','River','Empire','Secret','Journey','Legacy','Dreams','Shadows','Voices','Horizons','Memories'];
        return $adjectives[array_rand($adjectives)].' '.
               $nouns[array_rand($nouns)].' #'.rand(1000, 99999);
    }

    protected function fakeIsbn13(): string
    {
        $base = str_pad((string)rand(0, 999999999999), 12, '0', STR_PAD_LEFT);
        // Simple checksum (not strictly accurate but fine for demo)
        $sum = 0;
        for ($i=0; $i<12; $i++) { $sum += (int)$base[$i] * ($i % 2 === 0 ? 1 : 3); }
        $check = (10 - ($sum % 10)) % 10;
        return substr($base,0,3).'-'.substr($base,3,1).'-'.substr($base,4,4).'-'.substr($base,8,4).'-'.$check;
    }

    protected function downloadRandomCover(): ?string
    {
        try {
            $url = 'https://picsum.photos/seed/'.Str::random(12).'/400/600';
            $response = Http::timeout(10)->get($url);
            if (!$response->ok()) { return null; }
            $path = 'covers/'.Str::random(32).'.jpg';
            Storage::disk('public')->put($path, $response->body());
            return $path;
        } catch (\Throwable $e) {
            return null;
        }
    }
}


